/**
 * Manage macros which would be appended head of all shaders grimoire.js would load.
 */
export default class MacroRegistory {

  /**
   * Macro string which generated by registored macro.
   * @type {string}
   */
  public macroString: string = "";
  /**
   * The map of macro.
   */
  private _macro: { [macroName: string]: string } = {};

  /**
   * Handlers functions for changing macro.
   */
  private _observers: (() => void)[] = [];

  /**
   * Set the value of macros.
   * @param {string}    key [description]
   * @param {string =   null}        val [description]
   */
  public setValue(key: string, val: string = null): void {
    if (this._macro[key] !== val) {
      this._macro[key] = val;
      this.macroString = this._getMacroString();
      this._notifyMacroChanged();
    }
  }

  /**
   * Get the value of macro.
   * @param  {string} key [description]
   * @return {string}     [description]
   */
  public getValue(key: string): string {
    return this._macro[key];
  }

  public addObserver(handler: () => void): void {
    this._observers.push(handler);
  }

  public removeObserver(handler: () => void): void {
    for (let i = 0; i < this._observers.length; i++) {
      if (this._observers[i] === handler) {
        this._observers.splice(i, 1);
      }
    }
  }

  private _getMacroString(): string {
    let result = "";
    for (let key in this._macro) {
      result += this._genSingleMacroString(key, this._macro[key]);
    }
    return result;
  }

  private _notifyMacroChanged(): void {
    for (let i = 0; i < this._observers.length; i++) {
      this._observers[i]();
    }
  }

  /**
   * Generate macro string for single macro
   * @param  {string} key [description]
   * @param  {string} val [description]
   * @return {string}     [description]
   */
  private _genSingleMacroString(key: string, val: string): string {
    if (val) {
      return `#define ${key}\n`;
    } else {
      return `#define ${key} ${val}\n`;
    }
  }
}
